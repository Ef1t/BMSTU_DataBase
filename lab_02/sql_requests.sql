--1. Инструкция SELECT, использующая предикат сравнения.

select name, nickname from cybersportsmen
where country = 'Russian Federation'

--2. Инструкция SELECT, использующая предикат BETWEEN.

select name, nickname from cybersportsmen
where rating between 600 and 700

--3. Инструкция SELECT, использующая предикат LIKE.

select * from teams
where prize_amount like '$9%'

--4. Инструкция SELECT, использующая предикат IN с вложенным подзапросом. 

select name, nickname from cybersportsmen
where team in 
(select team_name from teams
where prize_amount like '$9%'

--5. Инструкция SELECT, использующая предикат EXISTS с вложенным подзапросом.

select id, name, nickname from cybersportsmen
where exists 
(select * from contracts
where contracts.player_id = cybersportsmen.id
)

--6. Инструкция SELECT, использующая предикат сравнения с квантором.

select name, nickname, rating from cybersportsmen
where rating > ALL
(select rating from cybersportsmen
 where country = 'Sweden'
)

--7. Инструкция SELECT, использующая агрегатные функции в выражениях столбцов.

select teams.team_name, count(teams.team_name) from cybersportsmen
join teams on cybersportsmen.team = teams.team_name
group by teams.team_name
order by count(teams.team_name) desc

--8. Инструкция SELECT, использующая скалярные подзапросы в выражениях столбцов.

select nickname from cybersportsmen 
where rating = (select max(rating) from cybersportsmen)

--9. Инструкция SELECT, использующая простое выражение CASE.

select name, nickname,
case country
when 'Russian Federation' then 'MOTHERRUSSIA'
else ''
end country
from cybersportsmen

--10. Инструкция SELECT, использующая поисковое выражение CASE.

select name, nickname,
case 
when country = 'Russian Federation' then 'MOTHERRUSSIA'
else ''
end country
from cybersportsmen

--11. Создание новой временной локальной таблицы из результирующего набора
--данных инструкции SELECT.

select name, nickname, country, rating
into russian_player from cybersportsmen 
where country = 'Russian Federation'

select * from russian_player

--12. Инструкция SELECT, использующая вложенные коррелированные подзапросы 
--в качестве производных таблиц в предложении FROM.

select * from (SELECT  name, nickname, 
(SELECT prize_amount FROM teams 
WHERE cybersportsmen.team = teams.team_name) AS team_amount
FROM cybersportsmen) as team_prize
where team_amount like '%9%'

--13. Инструкция SELECT, использующая вложенные подзапросы с уровнем
--вложенности 3.

select brands.brand_name, nickname, contracts_amount, brand_profit 
from brands 
	join (select brand_name, nickname, contracts_amount 
		from contracts 
		join (select * from cybersportsmen 
			where team = (select team_name from teams
				order by prize_amount desc
				limit 1)
		) as top_team 
on contracts.player_id = top_team.id) as brand_player
on brands.brand_name = brand_player.brand_name

--14. Инструкция SELECT, консолидирующая данные с помощью предложения
--GROUP BY, но без предложения HAVING.

select country, team_name, round(avg(cast(substring(teams.prize_amount, 2) as integer))) as average_prize_amount from teams
join cybersportsmen on 
cybersportsmen.team = teams.team_name
where country = 'Russian Federation'
group by team_name, country

--15. Инструкция SELECT, консолидирующая данные с помощью предложения
--GROUP BY и предложения HAVING.

select team, count(team) from cybersportsmen
group by team
having count(team) > 4

--16.Однострочная инструкция INSERT, выполняющая вставку в таблицу одной
--строки значений.

insert into teams
values ('Ulopopkinsi', 2020, '$9999999')

--17. Многострочная инструкция INSERT, выполняющая вставку в таблицу
--результирующего набора данных вложенного подзапроса.

insert into teams
values 
('Max_prize_team', 2019, (select max(prize_amount) from teams)), 
('What_team', 2019, '$96826858')

--18. Простая инструкция UPDATE.

update teams
set founded = 2004
where team_name = 'NAVI'

--19. Инструкция UPDATE со скалярным подзапросом в предложении SET.

update teams
set founded = (select min(founded) from teams)
where team_name = 'NAVI'

--20. Простая инструкция DELETE.

delete from teams
where team_name = 'What_team'

--21. Инструкция DELETE с вложенным коррелированным подзапросом в
--предложении WHERE.

delete from contracts
where player_id in (
select name, cs.player_id from contracts as cs 
join cybersportsmen as c1 
on cs.player_id = c1.id
where rating > 790

--22. Инструкция SELECT, использующая простое обобщенное табличное
--выражение

WITH CTE 
AS
(SELECT name, nickname, rating FROM cybersportsmen)
SELECT * FROM CTE

--23. Инструкция SELECT, использующая рекурсивное обобщенное табличное
--выражение.

CREATE TABLE cybersportsmen_substitute
(
	id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 ),
	name varchar(32) NOT NULL,
	nickname varchar(30) NOT NULL,
	substitute_for bigint NULL
);

INSERT INTO cybersportsmen_substitute (name, nickname, substitute_for)
VALUES ('Aleksandr Kostylev', 's1mple', NULL);

INSERT INTO cybersportsmen_substitute (name, nickname, substitute_for)
VALUES ('Nicola Kovac', 'niko', 1);

INSERT INTO cybersportsmen_substitute (name, nickname, substitute_for)
VALUES ('Lol Lolikov', 'l0l', 1);

INSERT INTO cybersportsmen_substitute (name, nickname, substitute_for)
VALUES ('Maksim Poner', 'Ullrite', 1);

INSERT INTO cybersportsmen_substitute (name, nickname, substitute_for)
VALUES ('Denis Sharipov', 'electronic', 2);

INSERT INTO cybersportsmen_substitute (name, nickname, substitute_for)
VALUES ('Kimo Woko', 'kiwo', 3);

INSERT INTO cybersportsmen_substitute (name, nickname, substitute_for)
VALUES ('Claud Mono', 'clamon', 6);

with recursive recCTE(id, name, nickname, substite_for, rotation_level)
as
(
select id, name, nickname, substitute_for, 0 as rotation_level
from cybersportsmen_substitute where substitute_for is null
union all
select cs.id, cs.name,cs.nickname, cs.substitute_for, rotation_level + 1
from cybersportsmen_substitute as cs join recCTE as rc on cs.substitute_for = rc.id
)

select * from recCTE order by rotation_level

--24. Оконные функции. Использование конструкций MIN/MAX/AVG OVER()

select name, nickname, country, 
min(cast(substring(prize_amount, 2) as integer)) over(partition by country) as "min",
max(cast(substring(prize_amount, 2) as integer)) over(partition by country) as "max",
round(avg(cast(substring(prize_amount, 2) as integer)) over(partition by country)) as "avg"
from cybersportsmen

--25. Оконные функции для устранения дублей

CREATE TABLE overlapping
(
	id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 ),
	name varchar(32) NOT NULL,
	nickname varchar(30) NOT NULL,
	country varchar(30) NOT NULL
);

INSERT INTO overlapping (name, nickname, country)
VALUES ('Lol Lolikov', 'l0l', 'Lolikovo'),
('Lol Lolikov', 'l0l', 'Lolikovo'),
('Kek Kekikov', 'k3k', 'Kekikovo'),
('Mem Memikov', 'mEm', 'Memikovo');

with cte
as
(select id, name, nickname, country,
row_number() over(partition BY name, nickname, country) AS row_number
FROM overlapping)

delete from overlapping
where id in (select id from cte
where row_number > 1)

/*
Дополнительное задание на дополнительные баллы
Создать таблицы:
• Table1{id: integer, var1: string, valid_from_dttm: date, valid_to_dttm: date}
• Table2{id: integer, var2: string, valid_from_dttm: date, valid_to_dttm: date}
Версионность в таблицах непрерывная, разрывов нет (если valid_to_dttm = '2018-09-05', то
для следующей строки соответсвующего ID valid_from_dttm = '2018-09-06', т.е. на день
больше). Для каждого ID дата начала версионности и дата конца версионности в Table1 и
Table2 совпадают.
Выполнить версионное соединение двух талиц по полю id.
*/

CREATE TABLE first(
  id INTEGER,
  var1 CHAR,
  from_dttm DATE,
  to_dttm DATE
);

CREATE TABLE second(
  id INTEGER,
  var2 CHAR,
  from_dttm DATE,
  to_dttm DATE
);

INSERT INTO first (id, var1, from_dttm, to_dttm) 
VALUES(1, 'A', '2018-09-01', '2018-09-15');
INSERT INTO first (id, var1, from_dttm, to_dttm) 
VALUES(1, 'B', '2018-09-16', '5999-12-31');
INSERT INTO second (id, var2, from_dttm, to_dttm) 
VALUES(1, 'A', '2018-09-01', '2018-09-14');
INSERT INTO second (id, var2, from_dttm, to_dttm) 
VALUES(1, 'B', '2018-09-15', '5999-12-31');

select * from 
(
    select first.id as id, first.var1 as var1, second.var2 as var2,
        case when first.from_dttm >= second.from_dttm then first.from_dttm
            else second.from_dttm 
        end as from_dttm,
        case when first.to_dttm <= second.to_dttm then first.to_dttm
            else second.to_dttm
        end as to_dttm
    from first left join second on first.id = second.id
) as res
where to_dttm >= from_dttm